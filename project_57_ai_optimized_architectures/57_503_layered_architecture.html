<!-- Enlighter Metainfo
{
  "id": 503,
  "title": "Layered Architecture",
  "next_button_title": "Next"
}
-->
<h5>2. Layered Architecture</h5>
<p>
    The Layered Architecture is a classic and widely-used design pattern. It organizes an application into horizontal layers, each with a specific responsibility. This separation of concerns makes the codebase easier to understand, maintain, and test.
</p>
<img style="margin: auto; display: block;" src="https://ucarecdn.com/7c892123-fc13-41e6-a5b1-d67aed2b910f/" alt="Layered Architecture" title="Layered Architecture">
<p>
    A typical web application might have three layers:
</p>
<ul>
    <li><b>Presentation Layer (UI):</b> Handles all user interface logic.</li>
    <li><b>Business Logic Layer (Domain):</b> Contains the core application logic and business rules.</li>
    <li><b>Data Access Layer:</b> Manages data persistence and retrieval.</li>
</ul>
<p>
    Dependencies in this architecture are strict and typically flow in one direction: Presentation â†’ Business Logic â†’ Data Access.
</p>

<h5>Advantages</h5>
<ul>
    <li>High cohesion and low coupling between layers.</li>
    <li>Promotes separation of concerns.</li>
    <li>Well-understood and familiar to many developers (and AIs).</li>
</ul>

<h5>Disadvantages</h5>
<ul>
    <li>Can be rigid; changes may require modifications across multiple layers.</li>
    <li>Can lead to unnecessary complexity for simple applications.</li>
</ul>

<h5>Let's Build a Snake Game</h5>
<p>
    Now, let's use an AI assistant to generate a Snake game using the Layered Architecture. First, we need to provide the AI with the game's specification and the architectural guidelines. The following blocks will create the necessary files.
</p>


<callout type="chat">

    Create a file /layered_architecture/architecture.md. Add the following content:

    You are working in a codebase that MUST follow **Pipeline Architecture (PA)**.

    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ”¹ 1. Core Idea
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Process data as a linear (or branched) **flow of stages**:
    
        Source  âœ  Stage 1  âœ  Stage 2  âœ â€¦ âœ  Sink
    
    â€¢ Each stage performs ONE atomic transformation, then immediately forwards the record.  
    â€¢ Stages run concurrently; different records may sit on different stages at the same time.  
    â€¢ Contracts (schema or typed DTO) between stages are explicit and version-controlled.
    
    â€œ**Do one thing, pass it on.**â€
    
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ”¹ 2. Folder & Naming Rules
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    src/
    â”œâ”€â”€ pipeline/
    â”‚   â”œâ”€â”€ stages/
    â”‚   â”‚   â”œâ”€â”€ 00_source.py        # emits records
    â”‚   â”‚   â”œâ”€â”€ 01_validate.py      # Stage 1
    â”‚   â”‚   â”œâ”€â”€ 02_enrich.py        # Stage 2
    â”‚   â”‚   â”œâ”€â”€ 03_predict.py       # Stage 3
    â”‚   â”‚   â”œâ”€â”€ 04_sink.py          # final drop-off
    â”‚   â”‚   â””â”€â”€ __tests__/
    â”‚   â”œâ”€â”€ runner.py               # wires queues, sets back-pressure, starts tasks
    â”‚   â”œâ”€â”€ contracts/              # Avro/Proto/JSON-Schema files
    â”‚   â”œâ”€â”€ shared/                 # generic utils (logging, metrics)
    â”‚   â””â”€â”€ config.yaml
    â””â”€â”€ README.md
    
    Convention notes  
    â€¢ Prefix stage files with a sequence number (**00**, **10**, **20**â€¦) so order is obvious.  
    
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ”¹ 3. Dependency Rules
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    âœ” Stage  â†’ contracts/, shared/, std-lib, third-party libs  
    âœ˜ Stage  â†’ another stageâ€™s **implementation** (no â€œreach-insideâ€)  
    âœ˜ Cyclic imports among stages or shared code  
    
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ”¹ 4. Code Generation & Refactoring
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    Create a new stage file or modify exactly ONE stage.  
    
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ”¹ 5. Best Practices
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â€¢ **Single-Responsibility Stage** â€“ validation â‰  enrichment â‰  ML inference.  
    â€¢ **Idempotent processing** â€“ a stage can safely re-run on the same record.  
    â€¢ **Explicit schemas** â€“ Avro/Proto/JSON-Schema stored under contracts/.  
    â€¢ **Dead-letter queue** â€“ send irrecoverable records to DLQ, donâ€™t stop the flow.  
    
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ”¹ 6. Your Role
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Whenever you create or modify code:
    
    1. **Identify the affected stage** (or insert a new one).  
    2. **Respect folder structure and dependency rules.**  

</callout>

<p>
    Now that the files are created, use the following prompt to ask the AI to generate the game.
</p>

<callout label="Generate the Snake game">
Generate an application based on the description from @/snake_game.md, designed as described in @/layered_architecture/architecture.md. Run the app when you have completed the implementation.
</callout>

<h5>Results from the Study</h5>
<p>
    The Layered Architecture achieved a 100% success rate for both initial generation and subsequent modifications, all while being the most token-efficient.
</p>
<table>
    <thead>
        <tr>
            <th>Metric</th>
            <th>Average Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>One-shot generation success</td>
            <td>5/5 (100%)</td>
        </tr>
        <tr>
            <td>One-shot modification success</td>
            <td>5/5 (100%)</td>
        </tr>
        <tr>
            <td>Architecture adherence (modification)</td>
            <td>5/5 (100%)</td>
        </tr>
        <tr>
            <td>Initial token consumption</td>
            <td>16.22k â†‘ / 248k â†“</td>
        </tr>
    </tbody>
</table>
<p>
    The study suggests that the AI's familiarity with this common pattern allowed it to generate and modify the code more reliably and efficiently.
</p>

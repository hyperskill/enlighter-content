<!-- Enlighter Metainfo
{
  "id": 504,
  "title": "Atomic Composable Architecture",
  "next_button_title": "Next"
}
-->
<h5>3. Atomic Composable Architecture (ACA)</h5>
<p>
    Atomic Composable Architecture borrows its concepts from Brad Frost's Atomic Design methodology and applies them to code organization. The core principle is to build complex systems from simple, predictable, and reusable components.
</p>

<p>
    ACA structures code into three levels of increasing complexity:
</p>
<ul>
    <li><b>Atoms:</b> The smallest, indivisible units of functionality, like a single function or constant. They have no internal dependencies.</li>
    <li><b>Molecules:</b> Small modules that are composed of several atoms to perform a specific function.</li>
    <li><b>Organisms:</b> Complete subsystems or features built by combining molecules.</li>
</ul>

<h5>Advantages</h5>
<ul>
    <li>High degree of modularity and reusability.</li>
    <li>Components are easy to test in isolation.</li>
    <li>Scales well as new functionality is added.</li>
</ul>

<h5>Disadvantages</h5>
<ul>
    <li>Can suffer from the "chain reaction" problem, where a change in a low-level atom requires changes in all dependent molecules and organisms.</li>
    <li>Requires strict discipline to manage dependencies.</li>
</ul>

<h5>Let's Build a Snake Game</h5>
<p>
    Let's build the Snake game again, this time using ACA. We'll use the same game specification but provide different architectural guidelines to the AI.
</p>



<callout type="chat">
    Create a file atomic_composable_architecture/architecture.md. Add the following content:

    You are working in a codebase that MUST follow **Atomic Composable Architecture (ACA)**.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”¹ 1. Core Idea
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Build complex features by composing tiny, self-contained units.  
The hierarchy is:

â€¢ **Atom** â€“ a single pure function / small class / constant (â‰ˆ 5-50 Lines of code).  
  â–¸ No runtime side-effects, no knowledge of the outside world, no imports from higher layers.

â€¢ **Molecule** â€“ a folder grouping several atoms plus tests (â‰ˆ 50-300 Lines of code).  
  â–¸ Exposes a minimal public interface; depends only on atoms or other molecules in the same folder.

â€¢ **Organism** â€“ a complete subsystem or service (â‰ˆ 300-1500 Lines of code).  
  â–¸ May hold state, start I/O, spin up workers, etc., but never leaks its internals upward.

Each layer can depend **only on its own layer or lower layers**â€”never upward.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”¹ 2. Folder Naming Rules
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
src/
â”œâ”€â”€ atoms/
â”‚   â””â”€â”€ {filename}*.{ext}
â”œâ”€â”€ molecules/
â”‚   â””â”€â”€ {filename}*.{ext}
â”œâ”€â”€ organisms/
â”‚   â””â”€â”€ {filename}*.{ext}
â””â”€â”€ main.{ext} (if needed)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”¹ 3. Allowed Imports
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ” Atom   â†’ std-lib, third-party libs, *never* other atoms.  
âœ” Molecule â†’ atoms in same folder, std-lib, third-party.  
âœ” Organism â†’ atoms & molecules, infrastructure libs.  
âœ˜ Cyclic or upward imports are forbidden and should fail lint/CI.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”¹ 4. Code Generation Targets
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
When generating or refactoring code, ALWAYS start at the lowest layer that changes the behavior.  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”¹ 5. Best Practices
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Pure functions first â€“ push side-effects to the edges (organisms).  
â€¢ Prefer dependency injection over global state.  
â€¢ One public export per file unless strongly justified.  
â€¢ Document any place an atomâ€™s change forces molecule/organism updates.
â€¢ Whenever you create or modify code **Decide the correct layer** (atom / molecule / organism).  
</callout>

<p>
    Use the following prompt to generate the game with ACA.
</p>

<callout label="Generate the Snake game">
Generate an application based on the description from @/snake_game.md, designed as described in @/atomic_composable_architecture/architecture.md. Run the app when you have completed the implementation.
</callout>

<h5>Results from the Study</h5>
<p>
    ACA performed well during the initial generation, with a 100% success rate. However, it struggled significantly with modifications. The study found that making changes often caused a "chain reaction" that broke the architecture's integrity.
</p>
<table>
    <thead>
        <tr>
            <th>Metric</th>
            <th>Average Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>One-shot generation success</td>
            <td>5/5 (100%)</td>
        </tr>
        <tr>
            <td>One-shot modification success</td>
            <td>3/5 (60%)</td>
        </tr>
        <tr>
            <td>Architecture adherence (modification)</td>
            <td>1/5 (20%)</td>
        </tr>
        <tr>
            <td>Initial token consumption</td>
            <td>25.88k â†‘ / 340.6k â†“</td>
        </tr>
    </tbody>
</table>
<p>
    This pattern is excellent for initial builds of applications with rich, composable functionality, but it may require more careful handling during maintenance and evolution.
</p>
